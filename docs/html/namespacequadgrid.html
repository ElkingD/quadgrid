<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="google-site-verification" content="fcJae5EEVzgANhd3VAup-yvCDINo9GehveTUvkksgQM" />
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
  <title>QuadGrid Docs</title>
</head>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacequadgrid.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">quadgrid Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c884db59c30e7e01ef808cc1f4b899e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a5c884db59c30e7e01ef808cc1f4b899e">gaussLegendreGrid</a> (const size_t N, std::vector&lt; double &gt; &amp;x, std::vector&lt; double &gt; &amp;w, const double a, const double b)</td></tr>
<tr class="memdesc:a5c884db59c30e7e01ef808cc1f4b899e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Gauss-Legendre quadrature nodes and weights.  <a href="#a5c884db59c30e7e01ef808cc1f4b899e">More...</a><br /></td></tr>
<tr class="separator:a5c884db59c30e7e01ef808cc1f4b899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be9a484b215dcca48a9cab340604e13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a0be9a484b215dcca48a9cab340604e13">legendrePoly</a> (std::vector&lt; double &gt; &amp;P, const double x, const size_t N)</td></tr>
<tr class="memdesc:a0be9a484b215dcca48a9cab340604e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Legendre polynomials ( P_0(x), P_1(x), , P_N(x) ).  <a href="#a0be9a484b215dcca48a9cab340604e13">More...</a><br /></td></tr>
<tr class="separator:a0be9a484b215dcca48a9cab340604e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e065a5b2f9c267509c51fb95a197c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a87e065a5b2f9c267509c51fb95a197c3">legendrePoly</a> (std::vector&lt; double &gt; &amp;P, std::vector&lt; double &gt; &amp;dPdx, const double x, const size_t N)</td></tr>
<tr class="memdesc:a87e065a5b2f9c267509c51fb95a197c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Legendre polynomials and their first derivatives at point ( x ).  <a href="#a87e065a5b2f9c267509c51fb95a197c3">More...</a><br /></td></tr>
<tr class="separator:a87e065a5b2f9c267509c51fb95a197c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2a131056c09d9299f5215d28d5c310"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#aed2a131056c09d9299f5215d28d5c310">sphereHarmonicArraySize</a> (size_t lmax)</td></tr>
<tr class="memdesc:aed2a131056c09d9299f5215d28d5c310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of complex spherical harmonic values Y(l,m), using a compact 1D layout.  <a href="#aed2a131056c09d9299f5215d28d5c310">More...</a><br /></td></tr>
<tr class="separator:aed2a131056c09d9299f5215d28d5c310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27f260822d5c82dc1443b07709fa23a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#ad27f260822d5c82dc1443b07709fa23a">sphereHarmonicArrayIndex</a> (size_t l, size_t m)</td></tr>
<tr class="memdesc:ad27f260822d5c82dc1443b07709fa23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flat array index for Y(l,m) where l &gt;= m &gt;= 0.  <a href="#ad27f260822d5c82dc1443b07709fa23a">More...</a><br /></td></tr>
<tr class="separator:ad27f260822d5c82dc1443b07709fa23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a8db2386e60b76228b34ca3d3d2719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a47a8db2386e60b76228b34ca3d3d2719">sphereHarmonic</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;Ylm, const size_t lmax, const double rUnit[3])</td></tr>
<tr class="memdesc:a47a8db2386e60b76228b34ca3d3d2719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes complex spherical harmonics Y(l,m) up to degree lmax using a Cartesian unit vector.  <a href="#a47a8db2386e60b76228b34ca3d3d2719">More...</a><br /></td></tr>
<tr class="separator:a47a8db2386e60b76228b34ca3d3d2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88a133c978f41ffe7242a0fa8f24039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#aa88a133c978f41ffe7242a0fa8f24039">sphereHarmonic</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;Ylm, const size_t lmax, const double theta, const double phi)</td></tr>
<tr class="memdesc:aa88a133c978f41ffe7242a0fa8f24039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes complex spherical harmonics Y(l,m) up to degree lmax using spherical coordinates.  <a href="#aa88a133c978f41ffe7242a0fa8f24039">More...</a><br /></td></tr>
<tr class="separator:aa88a133c978f41ffe7242a0fa8f24039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7176803c2d3f5b25b959c1a0c749088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#ad7176803c2d3f5b25b959c1a0c749088">unitSphereGaussLegendre</a> (const size_t lmax, size_t &amp;N, std::vector&lt; double &gt; &amp;theta, std::vector&lt; double &gt; &amp;w_theta, std::vector&lt; double &gt; &amp;phi)</td></tr>
<tr class="memdesc:ad7176803c2d3f5b25b959c1a0c749088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a spherical quadrature grid using Gauss-Legendre quadrature in the polar direction.  <a href="#ad7176803c2d3f5b25b959c1a0c749088">More...</a><br /></td></tr>
<tr class="separator:ad7176803c2d3f5b25b959c1a0c749088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6266939755ae280591bc62afa6081fdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a6266939755ae280591bc62afa6081fdc">unitSphereLebedev</a> (const size_t index, size_t &amp;lmax, size_t &amp;nPoint, std::vector&lt; double &gt; &amp;coord, std::vector&lt; double &gt; &amp;weight)</td></tr>
<tr class="memdesc:a6266939755ae280591bc62afa6081fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a Lebedev unit sphere grid by index.  <a href="#a6266939755ae280591bc62afa6081fdc">More...</a><br /></td></tr>
<tr class="separator:a6266939755ae280591bc62afa6081fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abc3d4bac67289be5fc8d62464d8d885f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#abc3d4bac67289be5fc8d62464d8d885f">Pi</a> = 3.1415926535897932384626433</td></tr>
<tr class="separator:abc3d4bac67289be5fc8d62464d8d885f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4582b5f0edf3a8dfe2de68b03138acaa"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a4582b5f0edf3a8dfe2de68b03138acaa">unitSphereLebedevNumGrid</a> = 11</td></tr>
<tr class="separator:a4582b5f0edf3a8dfe2de68b03138acaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4153d14cc3e2cb3387777e040a93c6f8"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#a4153d14cc3e2cb3387777e040a93c6f8">unitSphereLebedevLmax</a> [<a class="el" href="namespacequadgrid.html#a4582b5f0edf3a8dfe2de68b03138acaa">unitSphereLebedevNumGrid</a>]</td></tr>
<tr class="memdesc:a4153d14cc3e2cb3387777e040a93c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum spherical harmonic order (lmax) supported for each grid.  <a href="#a4153d14cc3e2cb3387777e040a93c6f8">More...</a><br /></td></tr>
<tr class="separator:a4153d14cc3e2cb3387777e040a93c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead2b58f6f9d4e7e627e968ce6a55f5b"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadgrid.html#aead2b58f6f9d4e7e627e968ce6a55f5b">unitSphereLebedevNumPoint</a> [<a class="el" href="namespacequadgrid.html#a4582b5f0edf3a8dfe2de68b03138acaa">unitSphereLebedevNumGrid</a>]</td></tr>
<tr class="memdesc:aead2b58f6f9d4e7e627e968ce6a55f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of integration points on the sphere for each Lebedev grid.  <a href="#aead2b58f6f9d4e7e627e968ce6a55f5b">More...</a><br /></td></tr>
<tr class="separator:aead2b58f6f9d4e7e627e968ce6a55f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5c884db59c30e7e01ef808cc1f4b899e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool quadgrid::gaussLegendreGrid </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Gauss-Legendre quadrature nodes and weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of quadrature points (order). Must be one of: {1, 2, 3.. 100} or {110, 120, 130, .. 1000} </td></tr>
    <tr><td class="paramname">x</td><td>Output vector to store the quadrature nodes (size N). </td></tr>
    <tr><td class="paramname">w</td><td>Output vector to store the corresponding weights (size N). </td></tr>
    <tr><td class="paramname">a</td><td>Lower bound of integration interval [a, b] </td></tr>
    <tr><td class="paramname">b</td><td>Upper bound of integration interval [a, b] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The weights and nodes are for integration over [a, b]. </dd></dl>

</div>
</div>
<a class="anchor" id="a0be9a484b215dcca48a9cab340604e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quadgrid::legendrePoly </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Legendre polynomials ( P_0(x), P_1(x), , P_N(x) ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Output vector that will contain ( N+1 ) values: P[0] through P[N]. </td></tr>
    <tr><td class="paramname">x</td><td>Input value at which to evaluate the polynomials. </td></tr>
    <tr><td class="paramname">N</td><td>Maximum order of the Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The output vector P is resized if necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="a87e065a5b2f9c267509c51fb95a197c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quadgrid::legendrePoly </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dPdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Legendre polynomials and their first derivatives at point ( x ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Output vector for Legendre polynomials ( P_0(x), , P_N(x) ) (size N+1). </td></tr>
    <tr><td class="paramname">dPdx</td><td>Output vector for first derivatives ( {d}{dx}P_0(x), , {d}{dx}P_N(x) ). </td></tr>
    <tr><td class="paramname">x</td><td>Input value at which to evaluate the polynomials and derivatives. </td></tr>
    <tr><td class="paramname">N</td><td>Maximum order of the Legendre polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both output vectors P and dPdx are resized if necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="a47a8db2386e60b76228b34ca3d3d2719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quadgrid::sphereHarmonic </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Ylm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rUnit</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes complex spherical harmonics Y(l,m) up to degree lmax using a Cartesian unit vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ylm</td><td>Output vector containing Y(l,m) values in compact layout (size = sphereHarmonicArraySize(lmax)). </td></tr>
    <tr><td class="paramname">lmax</td><td>Maximum degree to compute. </td></tr>
    <tr><td class="paramname">rUnit</td><td>Unit vector [x, y, z] on the sphere. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Computes only Y(l,m) for l &gt;= m &gt;= 0 </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacequadgrid_a47a8db2386e60b76228b34ca3d3d2719_icgraph.png" border="0" usemap="#namespacequadgrid_a47a8db2386e60b76228b34ca3d3d2719_icgraph" alt=""/></div>
<map name="namespacequadgrid_a47a8db2386e60b76228b34ca3d3d2719_icgraph" id="namespacequadgrid_a47a8db2386e60b76228b34ca3d3d2719_icgraph">
<area shape="rect" id="node2" href="namespacequadgrid.html#ad27f260822d5c82dc1443b07709fa23a" title="Computes the flat array index for Y(l,m) where l &gt;= m &gt;= 0. " alt="" coords="228,5,403,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aa88a133c978f41ffe7242a0fa8f24039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quadgrid::sphereHarmonic </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Ylm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes complex spherical harmonics Y(l,m) up to degree lmax using spherical coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ylm</td><td>Output vector containing Y(l,m) values in compact layout (size = sphereHarmonicArraySize(lmax)). </td></tr>
    <tr><td class="paramname">lmax</td><td>Maximum degree to compute. </td></tr>
    <tr><td class="paramname">theta</td><td>Polar angle 0 &lt;= theta &lt;= Pi (from +z axis). </td></tr>
    <tr><td class="paramname">phi</td><td>Azimuthal angle 0 &lt;= phi &lt;= 2*Pi (around z axis). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Computes only Y(l,m) for l &gt;= m &gt;= 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad27f260822d5c82dc1443b07709fa23a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t quadgrid::sphereHarmonicArrayIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flat array index for Y(l,m) where l &gt;= m &gt;= 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Degree index. </td></tr>
    <tr><td class="paramname">m</td><td>Order index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Linear index for accessing Y(l,m) in a flattened array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes a packed layout: [Y(0,0),Y(1,0),Y(1,1),Y(2,0),Y(2,1) ...] </dd></dl>

<p>Definition at line <a class="el" href="spherical__harmonic_8hpp_source.html#l00043">43</a> of file <a class="el" href="spherical__harmonic_8hpp_source.html">spherical_harmonic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  <span class="keywordflow">return</span> (l * (l + 1)) / 2 + m;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;}</div></div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacequadgrid_ad27f260822d5c82dc1443b07709fa23a_cgraph.png" border="0" usemap="#namespacequadgrid_ad27f260822d5c82dc1443b07709fa23a_cgraph" alt=""/></div>
<map name="namespacequadgrid_ad27f260822d5c82dc1443b07709fa23a_cgraph" id="namespacequadgrid_ad27f260822d5c82dc1443b07709fa23a_cgraph">
<area shape="rect" id="node2" href="namespacequadgrid.html#a47a8db2386e60b76228b34ca3d3d2719" title="Computes complex spherical harmonics Y(l,m) up to degree lmax using a Cartesian unit vector..." alt="" coords="228,13,403,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aed2a131056c09d9299f5215d28d5c310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t quadgrid::sphereHarmonicArraySize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of complex spherical harmonic values Y(l,m), using a compact 1D layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lmax</td><td>The maximum degree of the spherical harmonic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of Y(l,m) values for l &gt;= 0 and l &gt;= m &gt;= 0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array stores only non-negative m; negative m values are recovered using symmetry. </dd></dl>

<p>Definition at line <a class="el" href="spherical__harmonic_8hpp_source.html#l00033">33</a> of file <a class="el" href="spherical__harmonic_8hpp_source.html">spherical_harmonic.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  <span class="keywordflow">return</span> ((lmax + 1) * (lmax + 2)) / 2;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad7176803c2d3f5b25b959c1a0c749088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool quadgrid::unitSphereGaussLegendre </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a spherical quadrature grid using Gauss-Legendre quadrature in the polar direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lmax</td><td>Approximate order of the grid (max degree of spherical harmonics to integrate accurately). </td></tr>
    <tr><td class="paramname">N</td><td>Output number of polar grid points (will be approximately <code>lmax / 2</code>). </td></tr>
    <tr><td class="paramname">theta</td><td>Output vector of polar angles (   [0, ] ) (length N). </td></tr>
    <tr><td class="paramname">w_theta</td><td>Output vector of associated polar weights (length N). Azimuthal weights are folded into w_theta. </td></tr>
    <tr><td class="paramname">phi</td><td>Output vector of azimuthal angles (   [0, 2] ) (length 2×N). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success; <code>false</code> if <code>lmax</code> is out of bounds (e.g., too large or unsupported). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This grid uses Gauss-Legendre sampling in the polar direction and uniform sampling in the azimuthal direction. </dd>
<dd>
<code>lmax</code> should not exceed 2000 for accurate results. </dd></dl>

</div>
</div>
<a class="anchor" id="a6266939755ae280591bc62afa6081fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool quadgrid::unitSphereLebedev </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a Lebedev unit sphere grid by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index from 0 to 10 identifying the grid size and order. </td></tr>
    <tr><td class="paramname">lmax</td><td>Output: maximum spherical harmonic degree integrated accurately by this grid. </td></tr>
    <tr><td class="paramname">nPoint</td><td>Output: number of quadrature points on the unit sphere. </td></tr>
    <tr><td class="paramname">coord</td><td>Output: flattened coordinate array of size nPoint × 3 (x, y, z for each point). </td></tr>
    <tr><td class="paramname">weight</td><td>Output: quadrature weights for each point (size nPoint). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the index is valid; <code>false</code> if out of range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The integration error has been benchmarked by integrating spherical harmonics ( Y_^m ) over the sphere. Only the ( Y_0^0 ) integral should be nonzero. Errors for each grid index are listed below.</dd></dl>
<pre class="fragment">///   grid =  0  lmax =   9   maxError = 2.58e-16  rmsError = 6.57e-17
///   grid =  1  lmax =  11   maxError = 6.07e-16  rmsError = 1.20e-16
///   grid =  2  lmax =  17   maxError = 2.22e-15  rmsError = 2.97e-16
///   grid =  3  lmax =  23   maxError = 2.66e-15  rmsError = 2.52e-16
///   grid =  4  lmax =  25   maxError = 9.14e-15  rmsError = 8.19e-16
///   grid =  5  lmax =  27   maxError = 2.87e-15  rmsError = 4.73e-16
///   grid =  6  lmax =  29   maxError = 2.78e-15  rmsError = 2.36e-16
///   grid =  7  lmax =  41   maxError = 3.11e-15  rmsError = 2.14e-16
///   grid =  8  lmax =  47   maxError = 6.44e-15  rmsError = 2.33e-16
///   grid =  9  lmax =  53   maxError = 1.10e-14  rmsError = 3.39e-16
///   grid = 10  lmax = 131   maxError = 2.73e-14  rmsError = 3.21e-16
/// </pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="abc3d4bac67289be5fc8d62464d8d885f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double quadgrid::Pi = 3.1415926535897932384626433</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="constant_8hpp_source.html#l00022">22</a> of file <a class="el" href="constant_8hpp_source.html">constant.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4153d14cc3e2cb3387777e040a93c6f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t quadgrid::unitSphereLebedevLmax[<a class="el" href="namespacequadgrid.html#a4582b5f0edf3a8dfe2de68b03138acaa">unitSphereLebedevNumGrid</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">  9, 11, 17, 23, 25, 27, 29, 41, 47, 53, 131</div><div class="line">}</div></div><!-- fragment -->
<p>Maximum spherical harmonic order (lmax) supported for each grid. </p>

<p>Definition at line <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html#l00025">25</a> of file <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html">unit_sphere_grid_lebedev.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4582b5f0edf3a8dfe2de68b03138acaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t quadgrid::unitSphereLebedevNumGrid = 11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html#l00022">22</a> of file <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html">unit_sphere_grid_lebedev.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aead2b58f6f9d4e7e627e968ce6a55f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t quadgrid::unitSphereLebedevNumPoint[<a class="el" href="namespacequadgrid.html#a4582b5f0edf3a8dfe2de68b03138acaa">unitSphereLebedevNumGrid</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">  38, 50, 110, 194, 230, 266, 302, 590, 770, 974, 5810</div><div class="line">}</div></div><!-- fragment -->
<p>Number of integration points on the sphere for each Lebedev grid. </p>

<p>Definition at line <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html#l00031">31</a> of file <a class="el" href="unit__sphere__grid__lebedev_8hpp_source.html">unit_sphere_grid_lebedev.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacequadgrid.html">quadgrid</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
